target C {
	threading: false,
    build: "../scripts/build_nrf_unix.sh",
}

import IMU from "IMU.lf"
import Accelerometer from "Accelerometer.lf"

preamble {=
	//preamble
    #include <math.h>
=}


/**
* Given x, y, and z accelerometer readings in g's, output the tilt in the x and y directions.
* The outputs are in radians will be in the range of -PI/2 to PI/2.
*/
reactor Tilt {
    input x:float;
	input y:float;
	input z:float;

	output xz:float;
	output yz:float;
	
	reaction(x, y, z) -> xz, yz {=
        float ax, ay, az;
		if (z->is_present && x->is_present && y->is_present) {
			// extract values
		    ax = x->value;
			ay = y->value;
			az = z->value;
			// calculate tilt angles
            lf_set(xz, atanf(ax/sqrt(ay*ay + az*az)));
            lf_set(yz, atanf(ay/sqrt(ax*ax + az*az)));
		}
	=}
}

reactor IMUTilt {
	input trigger:bool;

	output xz:float;
	output yz:float;
	
	// sensors
	imu = new IMU();
	tilt = new Tilt();

	trigger -> imu.trigger;
	tilt.xz -> xz;
	tilt.yz -> yz;

	reaction(imu.acc) -> tilt.x, tilt.y, tilt.z {=
        // unpack acc struct
        // calculate tilt
        lf_set(tilt.x, imu.acc->value.x_axis);
        lf_set(tilt.y, imu.acc->value.y_axis);
        lf_set(tilt.z, imu.acc->value.z_axis);
    =}

}

reactor AccTilt {
	input trigger:bool;

	output roll:float;
	output pitch:float;

	acc = new Accelerometer();
	tilt = new Tilt();

	trigger -> acc.trigger;
	
	acc.x -> tilt.x;
	acc.y -> tilt.y;
	acc.z -> tilt.z;

	tilt.xz -> roll;
	tilt.yz -> pitch;
}